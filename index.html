<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="光头王的Blog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="光头王的Blog">
<meta property="og:url" content="https:&#x2F;&#x2F;weihong363.github.io&#x2F;index.html">
<meta property="og:site_name" content="光头王的Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://weihong363.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>光头王的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">光头王的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://weihong363.github.io/2019/10/22/Spring%20Cloud%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ironion">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="光头王的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/22/Spring%20Cloud%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Spring Cloud初探（一）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-22 20:07:43" itemprop="dateCreated datePublished" datetime="2019-10-22T20:07:43+08:00">2019-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-16 23:51:04" itemprop="dateModified" datetime="2019-11-16T23:51:04+08:00">2019-11-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>现如今微服务已算是一种比较流行的架构，很多招聘信息上动不动就要求要懂微服务。说到微服务，就不得不说Spring Cloud了。<br>Spring Cloud是一系列框架的集合，用它来开发分布式系统会非常方便。Spring Cloud提供了一系列工具可以使我们很方便地实现服务发现与注册(Spring Cloud Eureka、Zookeeper、Spring Cloud Consul)、配置中心(Spring Cloud Config)、负载均衡(Spring Cloud Ribbon、Spring Cloud Feign)、断路器(Spring Cloud Hystrix)、数据监控(Spring Cloud Sleuth、Zipkin)、网关(Spring Cloud Zuul、Spring Cloud Gateway)等等。下面就要来简单地学习下这些部分。</p>
<h3 id="二、Spring-Cloud"><a href="#二、Spring-Cloud" class="headerlink" title="二、Spring Cloud"></a>二、Spring Cloud</h3><p>![](Spring Cloud.png)</p>
<p>上面是我自己整理的一个思维导图，里面包括了Spring Cloud几个核心部分和一些常用的组成。在本文接下来的部分将对下列内容一一做介绍：</p>
<ol>
<li>服务发现（Spring Cloud Eureka、Zookeeper、Spring Cloud Consul）；</li>
<li>负载均衡（Spring Cloud Ribbon、Spring Cloud Feign）；</li>
<li>容错机制（Spring Cloud Hystrix）；</li>
<li>网关（Spring Cloud Zuul、Spring Cloud Gateway）；</li>
<li>配置中心（Spring Cloud Config、Apollo、Nacos）；</li>
<li>调用链监控（Spring Cloud Sleuth、Zipkin）。</li>
</ol>
<h4 id="1-服务发现"><a href="#1-服务发现" class="headerlink" title="1.服务发现"></a>1.服务发现</h4><p>在Spring Cloud中做服务发现的选择很多，有Spring Cloud Eureka、Spring Cloud Consul和Zookeeper，选择多了，麻烦也就来了，到底该选哪一种呢？</p>
<p>这里就不得不提到CAP定理了，在分布式领域有一个很著名的CAP定理：C：数据一致性。A：服务可用性。P：分区容错性（服务对网络分区故障的容错性）。</p>
<p>CAP定理也就是说在分布式存储系统中，最多只能实现以上两点。而由于当前网络延迟故障会导致丢包等问题，所以我们分区容错性是必须实现的。也就是NoSqL数据库P肯定要有，我们只能在一致性和可用性中进行选择，没有Nosql数据库能同时保证三点。（只能AP或者CP）</p>
<p>这里再来分别看下这三个注册中心：</p>
<ol>
<li>Spring Cloud Eureka。服务注册与发现。基于AP，保证了服务的高可用，默认开启了保护功能，即使注册服务超时，也不会从Eureka中注销，是Spring Cloud中比较常用的注册中心；</li>
<li>Zookeeper。同Eureka，也可做服务发现。不过其基于CP，不保证高可用，而是保证数据一致性；</li>
<li>Spring Cloud Consul。基于CP，且除了可作为服务注册中心之外还有很多扩展功能，比如说：配置中心、键值对存储、健康检查、多数据中心、Acl控制、日至快找生成等。</li>
</ol>
<p>下面看下这几个注册中心的对比：</p>
<ol>
<li><p>Spring Cloud Eureka : Zookeeper。最大的区别是Eureka保证AP, Zookeeper为CP。</p>
<p> ZooKeeper基于CP，不保证高可用，如果zookeeper正在选主，或者Zookeeper集群中半数以上机器不可用，那么将无法获得数据。</p>
<p> Eureka基于AP，能保证高可用，即使所有机器都挂了，也能拿到本地缓存的数据。作为注册中心，其实配置是不经常变动的，只有发版和机器出故障时会变。对于不经常变动的配置来说，CP是不合适的，而AP在遇到问题时可以用牺牲一致性来保证可用性，既返回旧数据，缓存数据。</p>
<p> 所以理论上Eureka是更适合作注册中心。而现实环境中大部分项目可能会使用ZooKeeper，那是因为集群不够大，并且基本不会遇到用做注册中心的机器一半以上都挂了的情况。所以实际上也没什么大问题。</p>
</li>
<li><p>Spring Cloud Eureka : Spring Cloud Consul。最大的区别也是Eureka保证AP, Consul为CP。</p>
<p> Consul强一致性(C)带来的是：<br> 服务注册相比Eureka会稍慢一些。因为Consul的raft协议要求必须过半数的节点都写入成功才认为注册成功<br> Leader挂掉时，重新选举期间整个consul不可用。保证了强一致性但牺牲了可用性。</p>
<p> Eureka保证高可用(A)和最终一致性：<br> 服务注册相对要快，因为不需要等注册信息replicate到其他节点，也不保证注册信息是否replicate成功<br> 当数据出现不一致时，虽然A, B上的注册信息不完全相同，但每个Eureka节点依然能够正常对外提供服务，这会出现查询服务信息时如果请求A查不到，但请求B就能查到。如此保证了可用性但牺牲了一致性。</p>
<p> 别看Spring Cloud Consul其他功能不少，不过在作为微服务的注册中心这一点上，个人认为还是Eureka更合适些。</p>
</li>
</ol>
<p>此外，Spring Cloud Eureka和Spring Cloud Consul相比还有个优点就是，他们都有UI界面，管理起来就方便很多。</p>
<h4 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2.负载均衡"></a>2.负载均衡</h4><p>负载均衡可以在客户端上实现，也可以在网关或者注册中心之类的实现，这里讨论的是客户端上的实现，其他部分先不管。</p>
<p>在服务提供者实现的方式，据我了解较常用的有两种：Spring Cloud Ribbon和Spring Cloud Feign。</p>
<h4 id="2-1-Spring-Cloud-Ribbon"><a href="#2-1-Spring-Cloud-Ribbon" class="headerlink" title="2.1 Spring Cloud Ribbon"></a>2.1 Spring Cloud Ribbon</h4><p>Spring Cloud Ribbon原来是Netflix公司的一个基于HTTP和TCP的负载均衡工具，后来贡献给了Spring Cloud。它通过Spring Cloud的封装，可以通过RestTemplate的请求转换成客户端负载均衡的调用，不像网关或者注册中心、配置中心之类的，还需要独立部署，直接写服务代码里就可以了。</p>
<p>而关于使用方面，其实就是两步：</p>
<ol>
<li><p>声明：</p>
<pre><code>@Bean

@LoadBalanced

public RestTemplate restTemplate() {

    return new RestTemplate();

}</code></pre></li>
<li><p>调用：</p>
<pre><code>@GetMapping(&quot;/{id}&quot;)

public User findById(@PathVariable Long id) {

    return this.restTemplate.getForObject(&quot;http://想调⽤的服务在eureka server上的名称/&quot; + id, User.class);

}</code></pre></li>
</ol>
<p>如果有首次请求慢的情况，则需要加入eager配置，如下：</p>
<pre><code>ribbon:
    eager-load:
        enabled: true
        clients: user</code></pre><p>不需要加依赖，因为在常用的Eureka的包里已经包含了Ribbon，如果使用其他的注册中心则根据实际情况去配置。</p>
<h4 id="2-2-Spring-Cloud-Feign"><a href="#2-2-Spring-Cloud-Feign" class="headerlink" title="2.2 Spring Cloud Feign"></a>2.2 Spring Cloud Feign</h4><p>在Ribbon中用到的RestTemplate在使用时，参数需要去做字符串拼接，要是参数一多，这么搞就效率很低，也不优雅。</p>
<p>这时候Feign就可以解决这个问题了。它也是由Netflix公司贡献的框架。Feign是一个声明式的客户端，它给出了HTTP请求的模板，我们只需要去写好接口，注解，就可以定义HTTP请求的参数、格式、地址等信息。</p>
<p>Feign整合了Ribbon和Hystrix，所以就不需要我们显示地去使用这两个组件了。因此，我们可以知道，Feign肯定支持负载均衡，此外还支持可插拔注解、可插拔HTTP编解码器、HTTP请求响应的压缩以及Hystrix的特性（这部分后面会讲到）。</p>
<p>而关于它的使用呢，其实就是加依赖、加注解、写配置、调用（Spring Cloud中多数组件的使用都是这套流程）：</p>
<ol>
<li><p>加依赖（引入这个依赖后会自动引入Hystrix的依赖）：</p>
 <dependency>

<p> <groupId>org.springframework.cloud</groupId></p>
<p> <artifactId>spring-cloud-starter-openfeign</artifactId></p>
 </dependency></li>
<li><p>加注解：</p>
<p> 启动类加 @EnableFeignClients</p>
<p> 编写另外新增一个包feign</p>
<p> 新建Feign Client（下方为示例代码）</p>
<p> @FeignClient(name = “microservice-provider-user”)</p>
<p> public interface UserFeignClient {</p>
<p> @RequestMapping(value = “/{id}”, method = RequestMethod.GET)</p>
<p> public User findById(@PathVariable(“id”) Long id);</p>
<p> }</p>
</li>
<li><p>写配置：</p>
<p> 1）配置类方式：</p>
<pre><code>@Configuration
public class FeignLogConfiguration {
    @Bean
    Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}

Feign有四种日志级别。
NONE：不记录任何日志（默认值）。
BASIC：仅记录请求方法、URL、响应状态代码以及执行时间。
HEADERS：记录BASIC级别的基础上，记录请求和响应的header。
FULL：记录请求和响应的header，body和元数据。
只对debug级别的日志有效。因此，还需在application.yml中配置：
    logging:
        level:    com.itmuch.cloud.study.user.feign.UserFeignClient: DEBUG
# 其中com.itmuch.cloud.study.user.feign.UserFeignClient是开启Feign日志的接口全名。</code></pre><p> <strong>WARNING</strong></p>
<pre><code>和Ribbon配置的定义一样，本例中的 FeignConfiguration 类也不能包含在主应用程序上下文的 @ComponentScan 中，否则该类中的配置信息就会被所有的 @FeignClient 共享。
因此，如果只想自定义某个Feign客户端的配置，必须防止@Configuration 注解的类所在的包与 @ComponentScan 扫描的包重叠，或应显式指定 @ComponentScan 不扫描@Configuration 类所在的包.</code></pre><p> 2)配置属性方式：</p>
<pre><code>配置指定名称的Feign Client
对于一个指定名称的Feign Client（例如该Feign Client的名称为 feignName ）：
feign:
client:
config:
feignName:
connectTimeout: 5000 # 相当于Request.Options
readTimeout: 5000 # 相当于Request.Options
# 配置Feign的日志级别，相当于代码配置方式中的Logger
loggerLevel: full
# Feign的错误解码器，相当于代码配置方式中的ErrorDecoder
errorDecoder: com.example.SimpleErrorDecoder
# 配置重试，相当于代码配置⽅式中的Retryer
retryer: com.example.SimpleRetryer
# 配置拦截器，相当于代码配置方式中的RequestInterceptor
requestInterceptors:- com.example.FooRequestInterceptor - com.example.BarRequestInterceptor
decode404: false

通用配置
上面讨论了如何配置特定名称的Feign Client，那么如果想为所有的Feign Client都进⾏配置，该怎么办呢？
我们知道， @EnableFeignClients 注解上有个 defaultConfiguration 属性，我们可以将默认配置写成一个类，然后用 defaultConfiguration 来引用，例如：
@EnableFeignClients(defaultConfiguration = DefaultRibbonConfig.class)
那么如果想使⽤配置属性该怎么办呢？
如果你想配置所有的Feign Client，只需像如下配置即可：
feign:
client:
config:
default:
connectTimeout: 5000
readTimeout: 5000
loggerLevel: basic

如果你不小心又使用了Java代码配置Feign，同时又使用了配置属性配置Feign，那么使用配置属性的优先级更高。配置属性配置的方式将会覆盖Java代码配置。如果你想修改代码配置方式的优先级，可使用如下属性： 
feign.client.default-to-properties=false 。</code></pre><p> 对于使用而言，这些配置不是必须的，根据需要配。</p>
</li>
<li><p>调用：</p>
<pre><code>@RestController
public class MovieController {
  @Autowired
  private UserFeignClient userFeignClient;

  @GetMapping(&quot;/user/{id}&quot;)
  public User findById(@PathVariable Long id) {
    return this.userFeignClient.findById(id);
  }
}</code></pre><p> 可以看到，使用Feign写的代码比Ribbon相对优雅一些。</p>
</li>
<li><p>扩展：</p>
<p> <em>继承</em></p>
<p> Feign支持继承。使⽤继承，我们可将⼀些公共操作分组到一些父接口中，从而简化Feign的开发。举个简单的例子：</p>
<p> 基础接口：UserService.java</p>
<pre><code>public interface UserService {
@RequestMapping(method = RequestMethod.GET, value =&quot;/users/{id}&quot;)
User getUser(@PathVariable(&quot;id&quot;) long id);
}</code></pre><p> 服务提供者要先添加对基础接口包的依赖，然后它的代码如下：UserResource.java</p>
<pre><code>@RestController
public class UserResource implements UserService {
@Override
User getUser(@PathVariable(&quot;id&quot;) long id) {
    ...覆盖接口方法
}
}</code></pre><p> 可以看到，这里我们不需要再加RequestMapping了，不过方法上的参数注解还是要加，如果有返回JSON数据，则还需要加@ResponsBody，因为这几个注解是不能继承的（虽然RequestMapping也不能继承，但是在判断的时候如果子类没有就会去父类找）</p>
<p> 服务消费者要先添加对基础接口包的依赖，然后它的代码如下：UserClient.java</p>
<pre><code>@FeignClient(&quot;users&quot;)
public interface UserClient extends UserService {
}</code></pre><p> 这个接口中不需要添加任何方法，方法都在父接口中，这里只需要在类上面添加@FeignClient(“users”)注解来绑定服务即可。</p>
<p> <strong>WARNING</strong></p>
<p> 尽管Feign的继承可帮助我们进一步简化Feign的开发，但Spring Cloud官方指出——通常情况下，不建议在服务器端与客户端之间共享接口，因为这种方式造成了服务器端与客户端代码的紧耦合。并且，Feign本身并不使用Spring MVC的工作机制（方法参数映射不被继承）。</p>
<p> <em>压缩</em></p>
<p> 一些场景下，我们可能需要对请求或响应进⾏压缩，此时可使⽤以下属性启用Feign的压缩功能。</p>
<pre><code>//开启压缩
//请求
feign.compression.request.enabled=true
//响应
feign.compression.response.enabled=true</code></pre><p> 对于请求的压缩，Feign还提供了更为详细的设置，例如：</p>
<pre><code>feign.compression.request.enabled=true

//配置压缩文档类型及最小压缩的文档大小
feign.compression.request.mime-types=text/xml,application/xml,application/json
//因为开启压缩可以有效节约网络资源，但是会增加CPU压力，所以建议把最小压缩的文档大小适度调大一点
feign.compression.request.min-request-size=2048</code></pre><p> 其中， feign.compression.request.mime-types 用于支持的媒体类型列表，默认是text/xml、application/xml以及application/json。feign.compression.request.min-request-size 用于设置请求的最小阈值，默认是2048。</p>
<p> <em>文件上传</em></p>
<p> 早期的Spring Cloud中，Feign本身是没有上传文件的能力的，要想实现这一点，需要自己去编写 Encoder 去实现上传。现在我们幸福了很多。因为Feign官方提供了子项目feign-form ，其中实现了上传所需的 Encoder 。</p>
<p> 1.加依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt;
    &lt;artifactId&gt;feign-form&lt;/artifactId&gt;
    &lt;version&gt;3.0.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt;
    &lt;artifactId&gt;feign-form-spring&lt;/artifactId&gt;
    &lt;version&gt;3.0.3&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p> 2.编写Feign Client</p>
<pre><code>@FeignClient(name = &quot;ms-content-sample&quot;, configuration = UploadFeignClient.MultipartSupportConfig.class)

public interface UploadFeignClient {

    @RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.POST,produces = {MediaType.APPLICATION_JSON_UTF8_VALUE},consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @ResponseBody
    String handleFileUpload(@RequestPart(value = &quot;file&quot;) MultipartFile file);

    class MultipartSupportConfig {
    @Bean
    public Encoder feignFormEncoder() {return new SpringFormEncoder();}

    }

}</code></pre><p> 如代码所示，在这个Feign Client中，我们引用了配置类 MultipartSupportConfig ，在 MultipartSupportConfig 中，我们实例化了 SpringFormEncoder 。这样这个Feign Client就能够上传啦。</p>
<p> <strong>注意点</strong></p>
<p> @RequestMapping(value = “/upload”, method = RequestMethod.POST,produces = {MediaType.APPLICATION_JSON_UTF8_VALUE},consumes = MediaType.MULTIPART_FORM_DATA_VALUE)中的 produeces 、 consumes 不能少；接口定义中的注解 @RequestPart(value = “file”) 不能写成 @RequestParam(value = “file”)。</p>
<p> 最好将Hystrix的超时时间设长一点，例如5秒，否则可能文件还没上传完，Hystrix就超时了，从而导致客户端侧的报错。</p>
<h4 id="3-容错机制"><a href="#3-容错机制" class="headerlink" title="3.容错机制"></a>3.容错机制</h4><p>Spring Cloud中容错机制是采用Spring Cloud Hystrix来实现的。它是由Netflix开源的一个延迟和容错库，能够应对雪崩效应（调用链中某一点出错，从而导致调用它的点也出问题——级联故障，最终雪球越滚越大的现象）。它的主要通过下列几点实现延迟和容错：</p>
</li>
</ol>
<p>1.包裹请求：使用HystrixCommand（或HystrixObservableCommand）包裹对依赖的调用逻辑，每个命令在独立线程中执行。</p>
<p>2.跳闸机制（断路器）：当某服务的错误率超过一定阈值时，Hystrix可以自动或手动跳闸，停止请求该服务一段时间。</p>
<p>3.资源隔离（仓壁模式）：Hystrix为每个依赖都维护了一个小型的线程池（或信号量），如果该线程池已满，发往该依赖的请求就被立即拒绝。</p>
<p>4.监控（hystrix-dashboard）：Hystrix可以近乎实时地监控运行指标和配置的变化。</p>
<p>5.回退机制（fallback）：当请求失败、超时、被拒绝，或者当断路器打开时，执行回退逻辑。</p>
<p>6.自我修复：当断路器打开一段时间后，会自动进入“半打开”状态，允许一个请求访问依赖的服务，如果该请求成功，则关闭断路器，否则继续保持打开状态。</p>
<p>而对于Hystrix来说，它的核心其实就3部分：</p>
<ol>
<li>超时：超时这个没什么好说的，就是设置个超时时间，超时之后会执行回退机制（服务降级）；</li>
<li>舱壁模式：Hystrix为每个依赖都维护了一个小型的线程池（或信号量），如果该线程池已满，发往该依赖的请求就被立即拒绝。这个模式顾名思义就像船一样，船舱与船舱之间以舱壁隔离开。所以，当某个远程调用的请求出问题时，只影响到它自己的线程池，其他的线程池被隔离开不受影响。这种模式可以防止java容器崩溃。</li>
<li>断路器：当某服务的错误率超过一定阈值时，Hystrix可以自动或手动跳闸，停止请求该服务一段时间。当断路器打开一段时间后，会自动进入“半打开”状态，允许一个请求访问依赖的服务，如果该请求成功，则关闭断路器，否则继续保持打开状态,这种机制称为“自我修复”。</li>
</ol>
<p>此外，Hystrix当请求失败、超时、被拒绝，或者当断路器打开时，执行回退逻辑也就是服务降级（fallback）。</p>
<p>除了述几点外，Hystrix还提供了可视化监控功能（HystrixDashboard）。它只能监控单个微服务，为了能够监控整个集群，HystrixDashboard需要整合Turbine。</p>
<p>上面大致介绍了下容错机制这部分，下面来讲下具体的使用（已知Feign整合了Hystrix，下面将按两种情况讲）：</p>
<p><em>有使用Feign</em></p>
<ol>
<li><p>加依赖。已经有使用Feign，就不需要再加Hystrix的依赖了；</p>
</li>
<li><p>加注解：</p>
<pre><code>启动类
@EnableCircuitBreaker

使用
@HystrixCommand
@GetMapping(&quot;/user/{id}&quot;)
public User findById(@PathVariable Long id) {
    return this.restTemplate.getForObject(&quot;http://microservice-provider-user/&quot; + id, User.class);
}</code></pre></li>
<li><p>配置fallback获取异常：</p>
<pre><code>@HystrixCommand(fallbackMethod = &quot;findByIdFallback&quot;, commandProperties = {
@HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;5000&quot;),@HystrixProperty(name = &quot;metrics.rollingStats.timeInMilliseconds&quot;, value = &quot;10000&quot;)
}, 
threadPoolProperties = {@HystrixProperty(name = &quot;coreSize&quot;, value = &quot;1&quot;),@HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;10&quot;)})
@GetMapping(&quot;/user/{id}&quot;)
public User findById(@PathVariable Long id) {
    // ...
}</code></pre></li>
</ol>
<p>参考内容来源：</p>
<p>本篇绝大多数内容学习引用自周立大佬的文章</p>
<p><a href="https://www.jianshu.com/p/04e125382324" target="_blank" rel="noopener">https://www.jianshu.com/p/04e125382324</a></p>
<p><a href="https://www.jianshu.com/p/1bd66db5dc46" target="_blank" rel="noopener">https://www.jianshu.com/p/1bd66db5dc46</a></p>
<p><a href="https://www.cnblogs.com/huangjuncong/p/9053576.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangjuncong/p/9053576.html</a></p>
<p><a href="https://www.jianshu.com/p/eedb068d4227" target="_blank" rel="noopener">https://www.jianshu.com/p/eedb068d4227</a></p>
<p><a href="https://www.cnblogs.com/cjsblog/p/9391819.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjsblog/p/9391819.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://weihong363.github.io/2019/10/18/Dubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ironion">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="光头王的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/18/Dubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">Dubbo基础（二）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-18 14:31:51" itemprop="dateCreated datePublished" datetime="2019-10-18T14:31:51+08:00">2019-10-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇对Dubbo的架构、注册中心还有Dubbo SPI机制做了初步的了解。这里将接着来了解下服务提供者和消费者。</p>
<h3 id="一、服务提供者与服务消费者简介"><a href="#一、服务提供者与服务消费者简介" class="headerlink" title="一、服务提供者与服务消费者简介"></a>一、服务提供者与服务消费者简介</h3><h4 id="1-架构图浅析"><a href="#1-架构图浅析" class="headerlink" title="1.架构图浅析"></a>1.架构图浅析</h4><p>这两者顾名思义就是一个发布服务一个订阅服务的。可以再看下Dubbo的架构图：</p>
<p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg" alt></p>
<p>可以看出，Provider先基于Container启动，然后向注册中心发布服务，之后服Consumer再向注册中心订阅服务，注册中心再把已注册的服务列表发给Consumer。</p>
<p>Consumer启动时会去检测依赖的服务可不可用，那如果Provider没注册上，会抛出异常，阻止初始化完成。把dubbo:reference标签里的check属性值设为false即可在启动时忽略这个检查。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/10/18/Dubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://weihong363.github.io/2019/10/18/Dubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ironion">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="光头王的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/18/Dubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Dubbo基础（一）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-18 13:50:38" itemprop="dateCreated datePublished" datetime="2019-10-18T13:50:38+08:00">2019-10-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>在目前分布式领域，Dubbo算是比较常用的框架了，一般都是用Dubbo+ZK组合搭建一个分布式应用的。虽然个人使用上更偏向于Spring Cloud些，毕竟自带全家桶，整合各种组件都很方便。不过Dubbo既然作为国内多数公司在使用的分布式框架，也自然有他的可取之处。（注：本篇的内容都是根据Dubbo官网介绍的版本，即dubbo-2.6.4来学习的）</p>
<h3 id="二、架构"><a href="#二、架构" class="headerlink" title="二、架构###"></a>二、架构###</h3><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg" alt></p>
<p>上图是取自Dubbo官网的架构图。可以看到，Dubbo框架主要由四个节点组成：</p>
<ol>
<li>注册中心 Registry</li>
<li>服务提供者 Provider（启动需要基于容器Container来启动）</li>
<li>服务消费者 Consummer</li>
<li>监控中心 Monitor</li>
</ol>
<p>下面将分别介绍上述的几个节点：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/10/18/Dubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://weihong363.github.io/2019/10/17/Dubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ironion">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="光头王的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/17/Dubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">Dubbo基础（三）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-17 16:52:48" itemprop="dateCreated datePublished" datetime="2019-10-17T16:52:48+08:00">2019-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇大概了解了下Dubbo的负载均衡、服务引入和导出，本篇将来学习下Dubbo的集群容错部分。</p>
<p>Dubbo的集群容错主要包括以下几个部分：</p>
<ol>
<li>服务字典（或者说目录）-Directory：存储提供者信息的字典，即每个服务Invoker的集合；</li>
<li>服务路由-Router：服务字典在刷新Invoker集合列表时会先通过这个Router对服务进行路由，看看哪些服务匹配路由规则；</li>
<li>集群-Cluster：集群嘛，这个大家都很熟悉了，为了避免单点故障，所以会把应用部署到多台服务器上。而对于请求在集群中发送失败的情况，Dubbo也提供了5种容错方式，下面再细讲；</li>
<li>负载均衡-LoadBalance：为了使集群中的请求合理地发送给各台服务器，防止服务器接受的请求量过大或过小的情况，提供了几种算法：加权随机（RandomLoadBalance）、最小活跃数（LeastActiveLoadBalance）、一致性哈希（ConsistentHashLoadBalance）、加权轮询（RoundRobinLoadBalance）</li></ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/10/17/Dubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://weihong363.github.io/2019/08/27/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E4%B8%AA%E4%BA%BA%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ironion">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="光头王的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/27/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E4%B8%AA%E4%BA%BA%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">ThreadPoolExcutor源码个人浅析（二）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-27 11:59:28" itemprop="dateCreated datePublished" datetime="2019-08-27T11:59:28+08:00">2019-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、源码浅析"><a href="#一、源码浅析" class="headerlink" title="一、源码浅析"></a>一、源码浅析</h3><h4 id="（1）构造方法"><a href="#（1）构造方法" class="headerlink" title="（1）构造方法"></a>（1）构造方法</h4><p>ThreadPoolExcutor共有四种构造方法，分别为：</p>
<ul>
<li>ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue)</Runnable></li>
<li>ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory)</Runnable></li>
<li>ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,RejectedExecutionHandler handler)</Runnable></li>
<li>ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</Runnable></li>
</ul>
<p>以下将结合代码和注释一一分析：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/08/27/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E4%B8%AA%E4%BA%BA%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://weihong363.github.io/2019/08/27/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E4%B8%AA%E4%BA%BA%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ironion">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="光头王的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/27/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E4%B8%AA%E4%BA%BA%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">ThreadPoolExcutor源码个人浅析（一）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-27 11:59:21" itemprop="dateCreated datePublished" datetime="2019-08-27T11:59:21+08:00">2019-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>由于前不久面试的时候涉及到这部分的知识点，比较不熟，所以在此写篇博客，给自己加深下理解，也方便忘记的时候再捡起来。</p>
<h3 id="二、源码浅析"><a href="#二、源码浅析" class="headerlink" title="二、源码浅析"></a>二、源码浅析</h3><p>俗话说，掌握一项技能，要知其然，亦要知其所以然。要用当然容易，不过不知其原理，哪天踩坑的时候就得多花费很多时间了。话不多说，先来看下ThreadPoolExcutor的内部都有些啥。<br>首先，先看下这个类的属性：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/08/27/ThreadPoolExcutor%E6%BA%90%E7%A0%81%E4%B8%AA%E4%BA%BA%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://weihong363.github.io/2019/08/27/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E5%9F%BA%E7%A1%80%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ironion">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="光头王的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/27/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E5%9F%BA%E7%A1%80%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">缓存策略基础初探</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-27 11:59:08" itemprop="dateCreated datePublished" datetime="2019-08-27T11:59:08+08:00">2019-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>由于我个人对于缓存这块内容基础极为薄弱，在不久前一次面试中被逮着问了，当时大脑空空如也，对于缓存只能蹦出几个零零散散的片段：ecache,redis，读取缓存数据代替内存来优化读写速度,Map存储。所以那次面试也毫无悬念的GG了。没办法，只能从头来学习下缓存这块内容。</p>
<h3 id="二、缓存基础"><a href="#二、缓存基础" class="headerlink" title="二、缓存基础"></a>二、缓存基础</h3><h4 id="1、什么是缓存"><a href="#1、什么是缓存" class="headerlink" title="1、什么是缓存"></a>1、什么是缓存</h4><p>要想了解一个事物，就得从源头知道这东东是啥？为什么要有它？它存在的作用？</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/08/27/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E5%9F%BA%E7%A1%80%E5%88%9D%E6%8E%A2/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ironion</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ironion</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

</body>
</html>
